[{"E:\\Programming\\React Practice\\spirographer\\src\\index.js":"1","E:\\Programming\\React Practice\\spirographer\\src\\reportWebVitals.js":"2","E:\\Programming\\React Practice\\spirographer\\src\\Canvas.js":"3","E:\\Programming\\React Practice\\spirographer\\src\\CommandButton.js":"4","E:\\Programming\\React Practice\\spirographer\\src\\spirofunctions.js":"5","E:\\Programming\\React Practice\\spirographer\\src\\Parameter.js":"6","E:\\Programming\\React Practice\\spirographer\\src\\Spirograph.js":"7","E:\\Programming\\React Practice\\spirographer\\src\\SpiroTile.js":"8","E:\\Programming\\React Practice\\spirographer\\src\\TileButton.js":"9","E:\\Programming\\React Practice\\spirographer\\src\\Metric.js":"10","E:\\Programming\\React Practice\\spirographer\\src\\CurveParameter.js":"11"},{"size":508,"mtime":1607938919164,"results":"12","hashOfConfig":"13"},{"size":362,"mtime":499162500000,"results":"14","hashOfConfig":"13"},{"size":7677,"mtime":1608192075002,"results":"15","hashOfConfig":"13"},{"size":550,"mtime":1608133450369,"results":"16","hashOfConfig":"13"},{"size":3019,"mtime":1608192137854,"results":"17","hashOfConfig":"13"},{"size":2231,"mtime":1608192205544,"results":"18","hashOfConfig":"13"},{"size":2261,"mtime":1608128749191,"results":"19","hashOfConfig":"13"},{"size":1835,"mtime":1608132095590,"results":"20","hashOfConfig":"13"},{"size":524,"mtime":1608132314519,"results":"21","hashOfConfig":"13"},{"size":357,"mtime":1608048267075,"results":"22","hashOfConfig":"13"},{"size":891,"mtime":1608142247838,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"17g1iyr",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"26"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"E:\\Programming\\React Practice\\spirographer\\src\\index.js",[],["49","50"],"E:\\Programming\\React Practice\\spirographer\\src\\reportWebVitals.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\Canvas.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\CommandButton.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\spirofunctions.js",["51"],"export function gcd(a, b) {\r\n  if (b === 0)\r\n    return a;\r\n  else\r\n    return gcd(b, (a % b));\r\n}\r\n\r\nexport function randomParams(){\r\n  let R = Math.floor(Math.random() * 300) +1;//Radius A 500\r\n  let r = Math.floor(Math.random() * 300) +1;//Radius B 500\r\n  let d = Math.floor(Math.random() * 300) +1;//Distance 500\r\n  let u = Math.floor(Math.random() * Math.floor(361)); //Rotation only works when PPC is low\r\n  let p = 100; //Points per circle - Standardized at 100 for simple usage\r\n  let c =  Math.random() < 0.5?\"epi\":\"hypo\" //Curve type;\r\n  let s = 1 //Scale;\r\n  let params = \r\n    {\r\n      r1: R,\r\n      r2: r,\r\n      distance: d,\r\n      rotation: u,\r\n      ppc: p,\r\n      animation: 5,\r\n      animPlaying: false,\r\n      curveType: c,\r\n      scale: 100,\r\n    }\r\n  return params;\r\n}\r\n\r\nexport function generateSpiroPath(params) {\r\n  let {r1, r2, distance, rotation, ppc, curveType, scale} = params;\r\n  let origin = {\r\n    x: 400,\r\n    y: 300\r\n  }\r\n\r\n  scale = scale / 100\r\n\r\n  if (r1 ===0 || r2===0){\r\n    return \"\";\r\n  }\r\n\r\n  let SVGPath = [];\r\n  let angleStep = 2 * Math.PI / ppc;\r\n  let numRevolutions = r2/gcd(r1,r2);\r\n  let numPoints = ppc * numRevolutions\r\n  let angle = parseFloat(rotation) * Math.PI / 180;\r\n  let radiusDifference = r1 - r2;\r\n  let radiusSum = r1 + r2;\r\n  let radiusDifferenceRatio = radiusDifference/r2;\r\n  let radiusSumRatio = radiusDifference/r2;\r\n\r\n  \r\n  if(curveType===\"hypo\"){\r\n    let oldPoint ={\r\n      x: origin.x + radiusDifference * Math.cos(angle) + distance * Math.cos(angle* radiusDifferenceRatio),\r\n      y:origin.y + radiusDifference * Math.sin(angle) - distance * Math.sin(angle* radiusDifferenceRatio)\r\n    }\r\n    SVGPath.push(`M${scale * oldPoint.x}`,`${scale * oldPoint.y}`);\r\n    for(let i=0; i<numPoints; i++){\r\n      angle += angleStep;\r\n      let newPoint = {\r\n        x: origin.x + radiusDifference * Math.cos(angle) + distance * Math.cos(angle* radiusDifferenceRatio),\r\n        y: origin.y + radiusDifference * Math.sin(angle) - distance * Math.sin(angle* radiusDifferenceRatio)\r\n      } \r\n      \r\n      SVGPath.push(`L${scale * newPoint.x}`,`${scale * newPoint.y}`);\r\n      oldPoint = {\r\n        x: newPoint.x,\r\n        y: newPoint.y\r\n      }\r\n    }\r\n  }\r\n  else{\r\n    let oldPoint ={\r\n      x: origin.x + radiusSum * Math.cos(angle) - distance * Math.cos(angle* radiusSumRatio),\r\n      y:origin.y + radiusSum * Math.sin(angle) - distance * Math.sin(angle* radiusSumRatio)\r\n    }\r\n    SVGPath.push(`M${scale * oldPoint.x}`,`${scale * oldPoint.y}`);\r\n    for(let i=0; i<numPoints; i++){\r\n      angle += angleStep;\r\n      let newPoint = {\r\n        x: origin.x + radiusSum * Math.cos(angle) - distance * Math.cos(angle* radiusSumRatio),\r\n        y: origin.y + radiusSum * Math.sin(angle) - distance * Math.sin(angle* radiusSumRatio)\r\n      } \r\n      \r\n      SVGPath.push(`L${scale * newPoint.x}`,`${scale * newPoint.y}`);\r\n      oldPoint = {\r\n        x: newPoint.x,\r\n        y: newPoint.y\r\n      }\r\n    }\r\n  }\r\n  SVGPath = SVGPath.join(\" \");\r\n  return SVGPath;\r\n}","E:\\Programming\\React Practice\\spirographer\\src\\Parameter.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\Spirograph.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\SpiroTile.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\TileButton.js",[],["52","53"],"E:\\Programming\\React Practice\\spirographer\\src\\Metric.js",[],"E:\\Programming\\React Practice\\spirographer\\src\\CurveParameter.js",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":15,"column":7,"nodeType":"60","messageId":"61","endLine":15,"endColumn":8},{"ruleId":"54","replacedBy":"62"},{"ruleId":"56","replacedBy":"63"},"no-native-reassign",["64"],"no-negated-in-lhs",["65"],"no-unused-vars","'s' is assigned a value but never used.","Identifier","unusedVar",["64"],["65"],"no-global-assign","no-unsafe-negation"]